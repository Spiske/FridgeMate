import type { DeepPartial } from "./utils";
import { CommonFieldType } from "./CommonFieldType";
import { DocumentDataExtractorConfigurationElement } from "./DocumentDataExtractorConfigurationTypes";
import { DocumentDetectionResult } from "./DocumentScannerTypes";
import { GenericDocument } from "./GenericDocument";
import { Image } from "./bridge/image";
import { ProcessingMode } from "./CommonTypes";
import { ResultAccumulationConfiguration } from "./FrameAccumulationTypes";
/**
The status of the extraction process.

- `OK`:
   The document data was extracted.
- `OK_BUT_INVALID_DOCUMENT`:
   The document data was extracted. Some fields in the document have failed validation, e.g. because the document is damaged, not authentic, or does not have all required fields.
- `OK_BUT_NOT_CONFIRMED`:
   The document data was extracted. Some fields have not yet been confirmed.
- `SCANNING_IN_PROGRESS_STILL_FOCUSING`:
   Document data extraction in progress. Waiting for camera to finish focusing.
- `ERROR_NOTHING_FOUND`:
   No document was detected.
- `ERROR_BAD_CROP`:
   A document was detected at an angle or distance that would result in a poor quality crop.
- `ERROR_UNKNOWN_DOCUMENT`:
   A document was detected, but it does not match any supported document format.
- `ERROR_UNACCEPTABLE_DOCUMENT`:
   A supported document was detected, but it is unacceptable in the current configuration.
*/
export type DocumentDataExtractionStatus = 
/**
The document data was extracted.
*/
"OK" | 
/**
The document data was extracted. Some fields in the document have failed validation, e.g. because the document is damaged, not authentic, or does not have all required fields.
*/
"OK_BUT_INVALID_DOCUMENT" | 
/**
The document data was extracted. Some fields have not yet been confirmed.
*/
"OK_BUT_NOT_CONFIRMED" | 
/**
Document data extraction in progress. Waiting for camera to finish focusing.
*/
"SCANNING_IN_PROGRESS_STILL_FOCUSING" | 
/**
No document was detected.
*/
"ERROR_NOTHING_FOUND" | 
/**
A document was detected at an angle or distance that would result in a poor quality crop.
*/
"ERROR_BAD_CROP" | 
/**
A document was detected, but it does not match any supported document format.
*/
"ERROR_UNKNOWN_DOCUMENT" | 
/**
A supported document was detected, but it is unacceptable in the current configuration.
*/
"ERROR_UNACCEPTABLE_DOCUMENT";
/** @hidden */
export declare const DocumentDataExtractionStatusValues: ReadonlyArray<DocumentDataExtractionStatus>;
/**
Contains the result of running the document data extractor.
*/
export declare class DocumentDataExtractionResult {
    /**
    The status of the extraction process
    */
    readonly status: DocumentDataExtractionStatus;
    /**
    The extracted document
    */
    readonly document: GenericDocument | null;
    /**
    Result of the document detection in the input image.
    */
    readonly documentDetectionResult: DocumentDetectionResult;
    /**
    Crop of the document if it was detected.
    @defaultValue null;
    */
    readonly croppedImage: Image | null;
    /** @param source {@displayType `DeepPartial<DocumentDataExtractionResult>`} */
    constructor(source?: DeepPartial<DocumentDataExtractionResult>);
}
/**
Level of trust in the authenticity of the extracted document.

- `TRUSTED`:
   The extracted document is trusted, i.e. the scanner may assume that it's authentic. This allows certain optimizations that make extraction faster.
- `UNTRUSTED`:
   The extracted document is not trusted, i.e. its authenticity cannot be assumed. All fields will be read out independently and can be further verified. Extracting untrusted documents takes slightly longer, as the extractor is not allowed to employ certain time-saving optimizations.
*/
export type DocumentTrustMode = 
/**
The extracted document is trusted, i.e. the scanner may assume that it's authentic. This allows certain optimizations that make extraction faster.
*/
"TRUSTED" | 
/**
The extracted document is not trusted, i.e. its authenticity cannot be assumed. All fields will be read out independently and can be further verified. Extracting untrusted documents takes slightly longer, as the extractor is not allowed to employ certain time-saving optimizations.
*/
"UNTRUSTED";
/** @hidden */
export declare const DocumentTrustModeValues: ReadonlyArray<DocumentTrustMode>;
/**
Configuration for the document data extractor.
*/
export declare class DocumentDataExtractorConfiguration {
    /**
    Configuration for how to accumulate results.
    @defaultValue new ResultAccumulationConfiguration({});
    */
    resultAccumulationConfig: ResultAccumulationConfiguration;
    /**
    Normalized names of the fields to exclude from the result.
    @defaultValue [];
    */
    fieldExcludeList: string[];
    /**
    List of configuration elements for the document data extractor.
    @defaultValue [new DocumentDataExtractorCommonConfiguration({})];
    */
    configurations: DocumentDataExtractorConfigurationElement[];
    /**
    If true, crops of the detected documents and fields will be returned in the result.
    @defaultValue false;
    */
    returnCrops: boolean;
    /**
    Level of trust in the authenticity of the extracted document.
    @defaultValue "TRUSTED";
    */
    documentTrustMode: DocumentTrustMode;
    /**
    Scanners typically can produce better results from a single image if they are allowed to spend a longer time analyzing it.
    
    On the other hand, scanners can produce even better results if they can analyze multiple images of the same subject and cross-check and combine the results.
    The processing mode tells the scanner whether to optimize for single or multiple images of a subject.
    @defaultValue "AUTO";
    */
    processingMode: ProcessingMode;
    /** @param source {@displayType `DeepPartial<DocumentDataExtractorConfiguration>`} */
    constructor(source?: DeepPartial<DocumentDataExtractorConfiguration>);
}
/**
The status of the consistency verification.

- `OK`:
   All values that correspond to the same logical field are exactly equal.
- `OK_PUNCTUATION_UPPER_CASE_CLEANED`:
   All values that correspond to the same logical field are equal after punctuation is removed and all characters are converted to upper case.
- `OK_DEBURRED`:
   All values that correspond to the same logical field are equal after punctuation is removed, all characters are converted to upper case and diacritics are replaced with their base characters.
- `OK_DEBURRED_EXTENDED`:
   Same as OK_DEBURRED but allows replacing diacritics not only with their base characters but also with some more complex combinations. E.g., according to ICAO 9303 MRZ standard Ü can be replaced with U or UE or UXX.
- `OK_TRUNCATED`:
   In addition to OK_DEBURRED_EXTENDED, allows one string to be a prefix of another string. Correctly works with complex diacritics replacements. In particular, if one string is MUEL and another is MÜLLER, then they are considered equal up to truncation.
- `INCONSISTENT`:
   The values that correspond to the same logical field are inconsistent.
*/
export type ValueConsistency = 
/**
All values that correspond to the same logical field are exactly equal.
*/
"OK" | 
/**
All values that correspond to the same logical field are equal after punctuation is removed and all characters are converted to upper case.
*/
"OK_PUNCTUATION_UPPER_CASE_CLEANED" | 
/**
All values that correspond to the same logical field are equal after punctuation is removed, all characters are converted to upper case and diacritics are replaced with their base characters.
*/
"OK_DEBURRED" | 
/**
Same as OK_DEBURRED but allows replacing diacritics not only with their base characters but also with some more complex combinations. E.g., according to ICAO 9303 MRZ standard Ü can be replaced with U or UE or UXX.
*/
"OK_DEBURRED_EXTENDED" | 
/**
In addition to OK_DEBURRED_EXTENDED, allows one string to be a prefix of another string. Correctly works with complex diacritics replacements. In particular, if one string is MUEL and another is MÜLLER, then they are considered equal up to truncation.
*/
"OK_TRUNCATED" | 
/**
The values that correspond to the same logical field are inconsistent.
*/
"INCONSISTENT";
/** @hidden */
export declare const ValueConsistencyValues: ReadonlyArray<ValueConsistency>;
/**
Report of the field consistency verification.
*/
export declare class FieldConsistencyVerificationReport {
    /**
    Logical field that is being verified
    */
    readonly fieldType: CommonFieldType;
    /**
    The status of the consistency verification
    */
    readonly consistency: ValueConsistency;
    /**
    Full names of the fields that were considered during the verification.
    */
    readonly fieldFullNames: string[];
    /** @param source {@displayType `DeepPartial<FieldConsistencyVerificationReport>`} */
    constructor(source?: DeepPartial<FieldConsistencyVerificationReport>);
}
/**
Report of the document consistency verification. Shows whether information in the fields that correspond to the same logical field is consistent.
*/
export declare class ConsistencyVerificationReport {
    /**
    Overall status of the consistency verification. Corresponds to the most severe status of all fields.
    */
    readonly overallConsistency: ValueConsistency;
    /**
    List of reports for each field that was verified
    */
    readonly fieldDetails: FieldConsistencyVerificationReport[];
    /** @param source {@displayType `DeepPartial<ConsistencyVerificationReport>`} */
    constructor(source?: DeepPartial<ConsistencyVerificationReport>);
}
/**
The result of the value semantics verification.

- `SKIPPED`:
   Verification of the value semantics was skipped. For example, because the field is empty.
- `VALID`:
   No errors were detected during semantics verification. For example, the date of birth is in the past, the date of expiry is in the future.
- `INVALID`:
   Semantically invalid value. For example, the date of birth is in the future, the date of expiry is in the past.
*/
export type ValueSemantics = 
/**
Verification of the value semantics was skipped. For example, because the field is empty.
*/
"SKIPPED" | 
/**
No errors were detected during semantics verification. For example, the date of birth is in the past, the date of expiry is in the future.
*/
"VALID" | 
/**
Semantically invalid value. For example, the date of birth is in the future, the date of expiry is in the past.
*/
"INVALID";
/** @hidden */
export declare const ValueSemanticsValues: ReadonlyArray<ValueSemantics>;
/**
Report of the field value semantics verification.
*/
export declare class FieldValueSemantics {
    /**
    Full name of the field that was considered during the verification.
    */
    readonly fieldFullName: string;
    /**
    Shows whether the data in the field is semantically invalid, e.g. the date of birth is in the future.
    */
    readonly invalidSemantics: boolean;
    /** @param source {@displayType `DeepPartial<FieldValueSemantics>`} */
    constructor(source?: DeepPartial<FieldValueSemantics>);
}
/**
Report of a logical field value semantics verification. If some logical field, e.g. expiry date is present in multiple places in the document, it can occur that some entries are semantically correct and some are semantically incorrect. This report shows the overall status of the logical field value semantics verification and details for each field that was verified.
*/
export declare class CompositeFieldValueSemantics {
    /**
    Overall status of the logical value semantics verification. Corresponds to the most severe status of all fields, i.e. if at least one field is semantically incorrect, the overall status is semantically incorrect. If no fields are present, the overall status is SKIPPED.
    */
    readonly overallFieldValueSemantics: ValueSemantics;
    /**
    List of value semantics for each field corresponding to the same logical field.
    */
    readonly fieldDetails: FieldValueSemantics[];
    /** @param source {@displayType `DeepPartial<CompositeFieldValueSemantics>`} */
    constructor(source?: DeepPartial<CompositeFieldValueSemantics>);
}
/**
Report of the document value semantics verification.
*/
export declare class SemanticsVerificationReport {
    /**
    Overall status of the value semantics verification. Corresponds to the most severe status of all fields, i.e. if at least one field is semantically incorrect, the overall status is semantically incorrect. If some verifications are skipped, they do not impact the overall status.
    */
    readonly overallInvalidSemantics: boolean;
    /**
    Status of the expiry date semantics verification. Shows whether the expiry date in the document is in the future.
    */
    readonly expiryDateSemantics: CompositeFieldValueSemantics;
    /**
    Status of the issue date semantics verification. Shows whether the issue date in the document is in the past.
    */
    readonly issueDateSemantics: CompositeFieldValueSemantics;
    /**
    Status of the birth date semantics verification. Shows whether the birth date in the document is in the past.
    */
    readonly birthDateSemantics: CompositeFieldValueSemantics;
    /**
    Result of verification whether the issue date is before the expiry date.
    */
    readonly issueDateBeforeExpiryDate: ValueSemantics;
    /**
    Result of verification whether the birth date is before the issue date.
    */
    readonly birthDateBeforeIssueDate: ValueSemantics;
    /**
    Result of verification whether the birth date is before the expiry date.
    */
    readonly birthDateBeforeExpiryDate: ValueSemantics;
    /** @param source {@displayType `DeepPartial<SemanticsVerificationReport>`} */
    constructor(source?: DeepPartial<SemanticsVerificationReport>);
}
/**
Report of the suspicious data field verification.
*/
export declare class FieldSuspiciousDataVerificationReport {
    /**
    Full name of the field that was considered during the verification.
    */
    readonly fieldFullName: string;
    /**
    Shows whether the data in the field is suspicious, e.g. contains word "Sample" in the name.
    */
    readonly isSuspicious: boolean;
    /** @param source {@displayType `DeepPartial<FieldSuspiciousDataVerificationReport>`} */
    constructor(source?: DeepPartial<FieldSuspiciousDataVerificationReport>);
}
/**
Report of the suspicious data document verification.
*/
export declare class SuspiciousDataVerificationReport {
    /**
    Overall status of the suspicious data verification. Corresponds to the most severe status of all fields, i.e. if at least one field is suspicious, the overall status is suspicious.
    */
    readonly overallSuspiciousData: boolean;
    /**
    List of reports for each field that was verified.
    */
    readonly fieldDetails: FieldSuspiciousDataVerificationReport[];
    /** @param source {@displayType `DeepPartial<SuspiciousDataVerificationReport>`} */
    constructor(source?: DeepPartial<SuspiciousDataVerificationReport>);
}
/**
Report which shows whether the data in the field that can be validated is valid.
*/
export declare class FieldInvalidDataVerificationReport {
    /**
    Full name of the field that was considered during the verification.
    */
    readonly fieldFullName: string;
    /**
    Shows whether the data in the field is valid, e.g. if MRZ check digits are correct.
    */
    readonly isInvalid: boolean;
    /** @param source {@displayType `DeepPartial<FieldInvalidDataVerificationReport>`} */
    constructor(source?: DeepPartial<FieldInvalidDataVerificationReport>);
}
/**
Report of the field validation verification.
*/
export declare class InvalidDataVerificationReport {
    /**
    Overall status of the document verification. Corresponds to the most severe status of all fields, i.e. if at least one field is invalid, the overall status is invalid.
    */
    readonly overallIsInvalid: boolean;
    /**
    List of reports for each field that was verified.
    */
    readonly fieldDetails: FieldInvalidDataVerificationReport[];
    /** @param source {@displayType `DeepPartial<InvalidDataVerificationReport>`} */
    constructor(source?: DeepPartial<InvalidDataVerificationReport>);
}
/**
Overall status of the document verification.

- `OK`:
   All the verifications passed successfully.
- `OK_WITH_WARNINGS`:
   No verifications failed, but some of them returned warnings.
- `INVALID`:
   At least one verification failed.
*/
export type DocumentVerificationStatus = 
/**
All the verifications passed successfully.
*/
"OK" | 
/**
No verifications failed, but some of them returned warnings.
*/
"OK_WITH_WARNINGS" | 
/**
At least one verification failed.
*/
"INVALID";
/** @hidden */
export declare const DocumentVerificationStatusValues: ReadonlyArray<DocumentVerificationStatus>;
/**
Report of the document verification.
*/
export declare class DocumentVerificationReport {
    /**
    Overall status of the document verification
    */
    readonly overallVerificationStatus: DocumentVerificationStatus;
    /**
    Report of the document consistency verification. Shows whether information in the fields that correspond to the same logical field and is present in different parts of the document is consistent.
    */
    readonly consistencyVerificationReport: ConsistencyVerificationReport;
    /**
    Report of the semantics verification. Shows whether the values in the fields are semantically correct.
    */
    readonly semanticsVerificationReport: SemanticsVerificationReport;
    /**
    Shows whether the data in the document is suspicious, e.g. contains word "Sample" in the name.
    */
    readonly suspiciousDataVerificationReport: SuspiciousDataVerificationReport;
    /**
    Some fields in the documents allow validation, for example, MRZ contains check digits to verify the data. This report shows whether there are any invalid fields in the document.
    */
    readonly invalidDataVerificationReport: InvalidDataVerificationReport;
    /** @param source {@displayType `DeepPartial<DocumentVerificationReport>`} */
    constructor(source?: DeepPartial<DocumentVerificationReport>);
}
