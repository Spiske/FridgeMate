import type { commands } from "../worker/ScanbotSDK.Core";
import { BridgeApiEntrypoint } from "../compiled/bridge/BridgeApiEntrypoint";
export interface WorkerBridgeInitOptions {
    allowSimd?: boolean;
    allowThreads?: boolean;
    requestSuffix?: string;
}
export type CoreCommands = typeof commands;
export declare class WorkerBridge {
    static SINGLETON: WorkerBridge | null;
    private instance;
    private continuations;
    private nextTicketId;
    private errorInWorker;
    constructor(basePath: string, options: WorkerBridgeInitOptions);
    private post;
    /**
     * Let proxy = createProxy("copy") or createProxy("transfer").
     * We want to allow the following two types of calls to proxy:
     *  1) proxy.someMethod(args) should invoke this.post("someMethod", args, "copy" | "transfer")
     *  2) proxy.BarcodeScanner.someMethod(args) should invoke this.post("BarcodeScanner.someMethod", args, "copy" | "transfer")
     */
    private createProxy;
    private handleUnrecoverableError;
    readonly copyArgs: {
        __hasModuleFunction: (functionName: string) => Promise<any>;
        __callModuleFunction: (functionName: string, args?: any[]) => Promise<any>;
        BarcodeDocumentParser: import("../../core-types").WorkerBarcodeDocumentParser;
        BarcodeScanner: import("../../core-types").WorkerBarcodeScanner;
        CheckScanner: import("../../core-types").WorkerCheckScanner;
        CreditCardScanner: import("../../core-types").WorkerCreditCardScanner;
        DocumentClassifier: import("../../core-types").WorkerDocumentClassifier;
        DocumentDataExtractor: import("../../core-types").WorkerDocumentDataExtractor;
        DocumentQualityAnalyzer: import("../../core-types").WorkerDocumentQualityAnalyzer;
        DocumentScanner: import("../../core-types").WorkerDocumentScanner;
        ImageManipulator: import("../../core-types").WorkerImageManipulator;
        ImageProcessor: import("../../core-types").WorkerImageProcessor;
        MrzScanner: import("../../core-types").WorkerMrzScanner;
        MrzParser: import("../../core-types").WorkerMrzParser;
        OcrEngine: import("../../core-types").WorkerOcrEngine;
        TextPatternScanner: import("../../core-types").WorkerTextPatternScanner;
        VinScanner: import("../../core-types").WorkerVinScanner;
        initialize: (licenseKey?: string, enginePath?: string, appId?: string, options?: import("../worker/ScanbotSDK.Core").InitializeOptions) => Promise<void>;
        getLicenseInfo: () => Promise<import("../compiled/LicensingTypes").LicenseInfo>;
        encodeJpeg: (image: import("../../core-types").Image, quality?: number) => Promise<Uint8Array>;
        beginPdf: (options: {
            attributes?: {
                author?: string;
                creator?: string;
                title?: string;
                subject?: string;
                keywords?: string;
            };
            pageSize?: import("../compiled/PdfConfigurationTypes").PageSize;
            pageDirection?: import("../compiled/PdfConfigurationTypes").PageDirection;
            pageFit?: import("../compiled/PdfConfigurationTypes").PageFit;
            dpi?: number;
            jpegQuality?: number;
            resamplingMethod?: import("../compiled/PdfConfigurationTypes").ResamplingMethod;
            binarizationFilter?: ({
                filterType?: number;
            } & {
                readonly _type: "LegacyFilter";
            }) | ({
                outputMode?: import("../compiled/ParametricFilters").OutputMode;
            } & {
                readonly _type: "ScanbotBinarizationFilter";
            }) | ({
                outputMode?: import("../compiled/ParametricFilters").OutputMode;
                denoise?: number;
                radius?: number;
                preset?: import("../compiled/ParametricFilters").BinarizationFilterPreset;
            } & {
                readonly _type: "CustomBinarizationFilter";
            }) | ({
                radius?: number;
                borderWidthFraction?: number;
                blackOutliersFraction?: number;
                whiteOutliersFraction?: number;
                contrastEnhancement?: number;
                colorEnhancement?: number;
                paperWhitening?: number;
                paperWhiteningBias?: number;
            } & {
                readonly _type: "ColorDocumentFilter";
            }) | ({
                brightness?: number;
            } & {
                readonly _type: "BrightnessFilter";
            }) | ({
                contrast?: number;
            } & {
                readonly _type: "ContrastFilter";
            }) | ({
                borderWidthFraction?: number;
                blackOutliersFraction?: number;
                whiteOutliersFraction?: number;
            } & {
                readonly _type: "GrayscaleFilter";
            }) | ({
                blackPoint?: number;
                whitePoint?: number;
            } & {
                readonly _type: "WhiteBlackPointFilter";
            });
        }) => Promise<import("../compiled/utils").ObjectId<"PdfGenerationContext">>;
        addPageToPdf: (pdfOperation: import("../compiled/utils").ObjectId<"PdfGenerationContext">, image: import("../../core-types").Image, binarization?: import("../compiled/ParametricFilters").PageBinarization) => Promise<void>;
        addPageToPdfWithOcr: (pdfOperation: import("../compiled/utils").ObjectId<"PdfGenerationContext">, image: import("../../core-types").Image, binarization?: import("../compiled/ParametricFilters").PageBinarization) => Promise<void>;
        completePdf: (pdfOperation: import("../compiled/utils").ObjectId<"PdfGenerationContext">) => Promise<Uint8Array>;
        beginTiff: (options: {
            compression?: import("../compiled/TiffTypes").CompressionMode;
            jpegQuality?: number;
            zipCompressionLevel?: number;
            dpi?: number;
            userFields?: {
                tag?: number;
                name?: string;
                value?: ({
                    value?: number;
                } & {
                    readonly _type: "UserFieldDoubleValue";
                }) | ({
                    value?: string;
                } & {
                    readonly _type: "UserFieldStringValue";
                }) | ({
                    value?: number;
                } & {
                    readonly _type: "UserFieldIntValue";
                });
            }[];
            binarizationFilter?: ({
                filterType?: number;
            } & {
                readonly _type: "LegacyFilter";
            }) | ({
                outputMode?: import("../compiled/ParametricFilters").OutputMode;
            } & {
                readonly _type: "ScanbotBinarizationFilter";
            }) | ({
                outputMode?: import("../compiled/ParametricFilters").OutputMode;
                denoise?: number;
                radius?: number;
                preset?: import("../compiled/ParametricFilters").BinarizationFilterPreset;
            } & {
                readonly _type: "CustomBinarizationFilter";
            }) | ({
                radius?: number;
                borderWidthFraction?: number;
                blackOutliersFraction?: number;
                whiteOutliersFraction?: number;
                contrastEnhancement?: number;
                colorEnhancement?: number;
                paperWhitening?: number;
                paperWhiteningBias?: number;
            } & {
                readonly _type: "ColorDocumentFilter";
            }) | ({
                brightness?: number;
            } & {
                readonly _type: "BrightnessFilter";
            }) | ({
                contrast?: number;
            } & {
                readonly _type: "ContrastFilter";
            }) | ({
                borderWidthFraction?: number;
                blackOutliersFraction?: number;
                whiteOutliersFraction?: number;
            } & {
                readonly _type: "GrayscaleFilter";
            }) | ({
                blackPoint?: number;
                whitePoint?: number;
            } & {
                readonly _type: "WhiteBlackPointFilter";
            });
        }) => Promise<import("../compiled/utils").ObjectId<"TiffGenerationContext">>;
        addPageToTiff: (tiffOperation: import("../compiled/utils").ObjectId<"TiffGenerationContext">, image: import("../../core-types").Image, binarization: import("../compiled/ParametricFilters").PageBinarization) => Promise<void>;
        completeTiff: (tiffOperation: import("../compiled/utils").ObjectId<"TiffGenerationContext">) => Promise<Uint8Array>;
        releaseObject: <T>(objectToken: import("../compiled/utils").ObjectId<T>) => Promise<void>;
        version: () => Promise<string>;
    };
    readonly transferArgs: {
        __hasModuleFunction: (functionName: string) => Promise<any>;
        __callModuleFunction: (functionName: string, args?: any[]) => Promise<any>;
        BarcodeDocumentParser: import("../../core-types").WorkerBarcodeDocumentParser;
        BarcodeScanner: import("../../core-types").WorkerBarcodeScanner;
        CheckScanner: import("../../core-types").WorkerCheckScanner;
        CreditCardScanner: import("../../core-types").WorkerCreditCardScanner;
        DocumentClassifier: import("../../core-types").WorkerDocumentClassifier;
        DocumentDataExtractor: import("../../core-types").WorkerDocumentDataExtractor;
        DocumentQualityAnalyzer: import("../../core-types").WorkerDocumentQualityAnalyzer;
        DocumentScanner: import("../../core-types").WorkerDocumentScanner;
        ImageManipulator: import("../../core-types").WorkerImageManipulator;
        ImageProcessor: import("../../core-types").WorkerImageProcessor;
        MrzScanner: import("../../core-types").WorkerMrzScanner;
        MrzParser: import("../../core-types").WorkerMrzParser;
        OcrEngine: import("../../core-types").WorkerOcrEngine;
        TextPatternScanner: import("../../core-types").WorkerTextPatternScanner;
        VinScanner: import("../../core-types").WorkerVinScanner;
        initialize: (licenseKey?: string, enginePath?: string, appId?: string, options?: import("../worker/ScanbotSDK.Core").InitializeOptions) => Promise<void>;
        getLicenseInfo: () => Promise<import("../compiled/LicensingTypes").LicenseInfo>;
        encodeJpeg: (image: import("../../core-types").Image, quality?: number) => Promise<Uint8Array>;
        beginPdf: (options: {
            attributes?: {
                author?: string;
                creator?: string;
                title?: string;
                subject?: string;
                keywords?: string;
            };
            pageSize?: import("../compiled/PdfConfigurationTypes").PageSize;
            pageDirection?: import("../compiled/PdfConfigurationTypes").PageDirection;
            pageFit?: import("../compiled/PdfConfigurationTypes").PageFit;
            dpi?: number;
            jpegQuality?: number;
            resamplingMethod?: import("../compiled/PdfConfigurationTypes").ResamplingMethod;
            binarizationFilter?: ({
                filterType?: number;
            } & {
                readonly _type: "LegacyFilter";
            }) | ({
                outputMode?: import("../compiled/ParametricFilters").OutputMode;
            } & {
                readonly _type: "ScanbotBinarizationFilter";
            }) | ({
                outputMode?: import("../compiled/ParametricFilters").OutputMode;
                denoise?: number;
                radius?: number;
                preset?: import("../compiled/ParametricFilters").BinarizationFilterPreset;
            } & {
                readonly _type: "CustomBinarizationFilter";
            }) | ({
                radius?: number;
                borderWidthFraction?: number;
                blackOutliersFraction?: number;
                whiteOutliersFraction?: number;
                contrastEnhancement?: number;
                colorEnhancement?: number;
                paperWhitening?: number;
                paperWhiteningBias?: number;
            } & {
                readonly _type: "ColorDocumentFilter";
            }) | ({
                brightness?: number;
            } & {
                readonly _type: "BrightnessFilter";
            }) | ({
                contrast?: number;
            } & {
                readonly _type: "ContrastFilter";
            }) | ({
                borderWidthFraction?: number;
                blackOutliersFraction?: number;
                whiteOutliersFraction?: number;
            } & {
                readonly _type: "GrayscaleFilter";
            }) | ({
                blackPoint?: number;
                whitePoint?: number;
            } & {
                readonly _type: "WhiteBlackPointFilter";
            });
        }) => Promise<import("../compiled/utils").ObjectId<"PdfGenerationContext">>;
        addPageToPdf: (pdfOperation: import("../compiled/utils").ObjectId<"PdfGenerationContext">, image: import("../../core-types").Image, binarization?: import("../compiled/ParametricFilters").PageBinarization) => Promise<void>;
        addPageToPdfWithOcr: (pdfOperation: import("../compiled/utils").ObjectId<"PdfGenerationContext">, image: import("../../core-types").Image, binarization?: import("../compiled/ParametricFilters").PageBinarization) => Promise<void>;
        completePdf: (pdfOperation: import("../compiled/utils").ObjectId<"PdfGenerationContext">) => Promise<Uint8Array>;
        beginTiff: (options: {
            compression?: import("../compiled/TiffTypes").CompressionMode;
            jpegQuality?: number;
            zipCompressionLevel?: number;
            dpi?: number;
            userFields?: {
                tag?: number;
                name?: string;
                value?: ({
                    value?: number;
                } & {
                    readonly _type: "UserFieldDoubleValue";
                }) | ({
                    value?: string;
                } & {
                    readonly _type: "UserFieldStringValue";
                }) | ({
                    value?: number;
                } & {
                    readonly _type: "UserFieldIntValue";
                });
            }[];
            binarizationFilter?: ({
                filterType?: number;
            } & {
                readonly _type: "LegacyFilter";
            }) | ({
                outputMode?: import("../compiled/ParametricFilters").OutputMode;
            } & {
                readonly _type: "ScanbotBinarizationFilter";
            }) | ({
                outputMode?: import("../compiled/ParametricFilters").OutputMode;
                denoise?: number;
                radius?: number;
                preset?: import("../compiled/ParametricFilters").BinarizationFilterPreset;
            } & {
                readonly _type: "CustomBinarizationFilter";
            }) | ({
                radius?: number;
                borderWidthFraction?: number;
                blackOutliersFraction?: number;
                whiteOutliersFraction?: number;
                contrastEnhancement?: number;
                colorEnhancement?: number;
                paperWhitening?: number;
                paperWhiteningBias?: number;
            } & {
                readonly _type: "ColorDocumentFilter";
            }) | ({
                brightness?: number;
            } & {
                readonly _type: "BrightnessFilter";
            }) | ({
                contrast?: number;
            } & {
                readonly _type: "ContrastFilter";
            }) | ({
                borderWidthFraction?: number;
                blackOutliersFraction?: number;
                whiteOutliersFraction?: number;
            } & {
                readonly _type: "GrayscaleFilter";
            }) | ({
                blackPoint?: number;
                whitePoint?: number;
            } & {
                readonly _type: "WhiteBlackPointFilter";
            });
        }) => Promise<import("../compiled/utils").ObjectId<"TiffGenerationContext">>;
        addPageToTiff: (tiffOperation: import("../compiled/utils").ObjectId<"TiffGenerationContext">, image: import("../../core-types").Image, binarization: import("../compiled/ParametricFilters").PageBinarization) => Promise<void>;
        completeTiff: (tiffOperation: import("../compiled/utils").ObjectId<"TiffGenerationContext">) => Promise<Uint8Array>;
        releaseObject: <T>(objectToken: import("../compiled/utils").ObjectId<T>) => Promise<void>;
        version: () => Promise<string>;
    };
    readonly api: BridgeApiEntrypoint;
    destroy(): void;
}
