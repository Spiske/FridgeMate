import { WorkerBridge as CoreWorkerBridge, WorkerBridgeInitOptions } from "../core/bridge/worker-bridge";
import { BridgeApiEntrypoint } from "../core/compiled/bridge/BridgeApiEntrypoint";
export declare class WorkerBridge {
    private readonly core;
    /** Will be resolved once the core is initialized */
    private readonly initializationStatus;
    constructor(path: string, options: WorkerBridgeInitOptions, initializeArgs: Parameters<CoreWorkerBridge["copyArgs"]["initialize"]>);
    awaitInitialized(): Promise<void>;
    private createProxy;
    readonly copyArgs: {
        __hasModuleFunction: (functionName: string) => Promise<any>;
        __callModuleFunction: (functionName: string, args?: any[]) => Promise<any>;
        BarcodeDocumentParser: import("../core-types").WorkerBarcodeDocumentParser;
        BarcodeScanner: import("../core-types").WorkerBarcodeScanner;
        CheckScanner: import("../core-types").WorkerCheckScanner;
        CreditCardScanner: import("../core-types").WorkerCreditCardScanner;
        DocumentClassifier: import("../core-types").WorkerDocumentClassifier;
        DocumentDataExtractor: import("../core-types").WorkerDocumentDataExtractor;
        DocumentQualityAnalyzer: import("../core-types").WorkerDocumentQualityAnalyzer;
        DocumentScanner: import("../core-types").WorkerDocumentScanner;
        ImageManipulator: import("../core-types").WorkerImageManipulator;
        ImageProcessor: import("../core-types").WorkerImageProcessor;
        MrzScanner: import("../core-types").WorkerMrzScanner;
        MrzParser: import("../core-types").WorkerMrzParser;
        OcrEngine: import("../core-types").WorkerOcrEngine;
        TextPatternScanner: import("../core-types").WorkerTextPatternScanner;
        VinScanner: import("../core-types").WorkerVinScanner;
        initialize: (licenseKey?: string, enginePath?: string, appId?: string, options?: import("../core-types").InitializeOptions) => Promise<void>;
        getLicenseInfo: () => Promise<import("../core-types").LicenseInfo>;
        encodeJpeg: (image: import("../core-types").Image, quality?: number) => Promise<Uint8Array>;
        beginPdf: (options: {
            attributes?: {
                author?: string;
                creator?: string;
                title?: string;
                subject?: string;
                keywords?: string;
            };
            pageSize?: import("../core-types").PageSize;
            pageDirection?: import("../core-types").PageDirection;
            pageFit?: import("../core-types").PageFit;
            dpi?: number;
            jpegQuality?: number;
            resamplingMethod?: import("../core-types").ResamplingMethod;
            binarizationFilter?: ({
                filterType?: number;
            } & {
                readonly _type: "LegacyFilter";
            }) | ({
                outputMode?: import("../core-types").OutputMode;
            } & {
                readonly _type: "ScanbotBinarizationFilter";
            }) | ({
                outputMode?: import("../core-types").OutputMode;
                denoise?: number;
                radius?: number;
                preset?: import("../core-types").BinarizationFilterPreset;
            } & {
                readonly _type: "CustomBinarizationFilter";
            }) | ({
                radius?: number;
                borderWidthFraction?: number;
                blackOutliersFraction?: number;
                whiteOutliersFraction?: number;
                contrastEnhancement?: number;
                colorEnhancement?: number;
                paperWhitening?: number;
                paperWhiteningBias?: number;
            } & {
                readonly _type: "ColorDocumentFilter";
            }) | ({
                brightness?: number;
            } & {
                readonly _type: "BrightnessFilter";
            }) | ({
                contrast?: number;
            } & {
                readonly _type: "ContrastFilter";
            }) | ({
                borderWidthFraction?: number;
                blackOutliersFraction?: number;
                whiteOutliersFraction?: number;
            } & {
                readonly _type: "GrayscaleFilter";
            }) | ({
                blackPoint?: number;
                whitePoint?: number;
            } & {
                readonly _type: "WhiteBlackPointFilter";
            });
        }) => Promise<import("../core-types").ObjectId<"PdfGenerationContext">>;
        addPageToPdf: (pdfOperation: import("../core-types").ObjectId<"PdfGenerationContext">, image: import("../core-types").Image, binarization?: import("../core-types").PageBinarization) => Promise<void>;
        addPageToPdfWithOcr: (pdfOperation: import("../core-types").ObjectId<"PdfGenerationContext">, image: import("../core-types").Image, binarization?: import("../core-types").PageBinarization) => Promise<void>;
        completePdf: (pdfOperation: import("../core-types").ObjectId<"PdfGenerationContext">) => Promise<Uint8Array>;
        beginTiff: (options: {
            compression?: import("../core-types").CompressionMode;
            jpegQuality?: number;
            zipCompressionLevel?: number;
            dpi?: number;
            userFields?: {
                tag?: number;
                name?: string;
                value?: ({
                    value?: number;
                } & {
                    readonly _type: "UserFieldDoubleValue";
                }) | ({
                    value?: string;
                } & {
                    readonly _type: "UserFieldStringValue";
                }) | ({
                    value?: number;
                } & {
                    readonly _type: "UserFieldIntValue";
                });
            }[];
            binarizationFilter?: ({
                filterType?: number;
            } & {
                readonly _type: "LegacyFilter";
            }) | ({
                outputMode?: import("../core-types").OutputMode;
            } & {
                readonly _type: "ScanbotBinarizationFilter";
            }) | ({
                outputMode?: import("../core-types").OutputMode;
                denoise?: number;
                radius?: number;
                preset?: import("../core-types").BinarizationFilterPreset;
            } & {
                readonly _type: "CustomBinarizationFilter";
            }) | ({
                radius?: number;
                borderWidthFraction?: number;
                blackOutliersFraction?: number;
                whiteOutliersFraction?: number;
                contrastEnhancement?: number;
                colorEnhancement?: number;
                paperWhitening?: number;
                paperWhiteningBias?: number;
            } & {
                readonly _type: "ColorDocumentFilter";
            }) | ({
                brightness?: number;
            } & {
                readonly _type: "BrightnessFilter";
            }) | ({
                contrast?: number;
            } & {
                readonly _type: "ContrastFilter";
            }) | ({
                borderWidthFraction?: number;
                blackOutliersFraction?: number;
                whiteOutliersFraction?: number;
            } & {
                readonly _type: "GrayscaleFilter";
            }) | ({
                blackPoint?: number;
                whitePoint?: number;
            } & {
                readonly _type: "WhiteBlackPointFilter";
            });
        }) => Promise<import("../core-types").ObjectId<"TiffGenerationContext">>;
        addPageToTiff: (tiffOperation: import("../core-types").ObjectId<"TiffGenerationContext">, image: import("../core-types").Image, binarization: import("../core-types").PageBinarization) => Promise<void>;
        completeTiff: (tiffOperation: import("../core-types").ObjectId<"TiffGenerationContext">) => Promise<Uint8Array>;
        releaseObject: <T>(objectToken: import("../core-types").ObjectId<T>) => Promise<void>;
        version: () => Promise<string>;
    };
    readonly transferArgs: {
        __hasModuleFunction: (functionName: string) => Promise<any>;
        __callModuleFunction: (functionName: string, args?: any[]) => Promise<any>;
        BarcodeDocumentParser: import("../core-types").WorkerBarcodeDocumentParser;
        BarcodeScanner: import("../core-types").WorkerBarcodeScanner;
        CheckScanner: import("../core-types").WorkerCheckScanner;
        CreditCardScanner: import("../core-types").WorkerCreditCardScanner;
        DocumentClassifier: import("../core-types").WorkerDocumentClassifier;
        DocumentDataExtractor: import("../core-types").WorkerDocumentDataExtractor;
        DocumentQualityAnalyzer: import("../core-types").WorkerDocumentQualityAnalyzer;
        DocumentScanner: import("../core-types").WorkerDocumentScanner;
        ImageManipulator: import("../core-types").WorkerImageManipulator;
        ImageProcessor: import("../core-types").WorkerImageProcessor;
        MrzScanner: import("../core-types").WorkerMrzScanner;
        MrzParser: import("../core-types").WorkerMrzParser;
        OcrEngine: import("../core-types").WorkerOcrEngine;
        TextPatternScanner: import("../core-types").WorkerTextPatternScanner;
        VinScanner: import("../core-types").WorkerVinScanner;
        initialize: (licenseKey?: string, enginePath?: string, appId?: string, options?: import("../core-types").InitializeOptions) => Promise<void>;
        getLicenseInfo: () => Promise<import("../core-types").LicenseInfo>;
        encodeJpeg: (image: import("../core-types").Image, quality?: number) => Promise<Uint8Array>;
        beginPdf: (options: {
            attributes?: {
                author?: string;
                creator?: string;
                title?: string;
                subject?: string;
                keywords?: string;
            };
            pageSize?: import("../core-types").PageSize;
            pageDirection?: import("../core-types").PageDirection;
            pageFit?: import("../core-types").PageFit;
            dpi?: number;
            jpegQuality?: number;
            resamplingMethod?: import("../core-types").ResamplingMethod;
            binarizationFilter?: ({
                filterType?: number;
            } & {
                readonly _type: "LegacyFilter";
            }) | ({
                outputMode?: import("../core-types").OutputMode;
            } & {
                readonly _type: "ScanbotBinarizationFilter";
            }) | ({
                outputMode?: import("../core-types").OutputMode;
                denoise?: number;
                radius?: number;
                preset?: import("../core-types").BinarizationFilterPreset;
            } & {
                readonly _type: "CustomBinarizationFilter";
            }) | ({
                radius?: number;
                borderWidthFraction?: number;
                blackOutliersFraction?: number;
                whiteOutliersFraction?: number;
                contrastEnhancement?: number;
                colorEnhancement?: number;
                paperWhitening?: number;
                paperWhiteningBias?: number;
            } & {
                readonly _type: "ColorDocumentFilter";
            }) | ({
                brightness?: number;
            } & {
                readonly _type: "BrightnessFilter";
            }) | ({
                contrast?: number;
            } & {
                readonly _type: "ContrastFilter";
            }) | ({
                borderWidthFraction?: number;
                blackOutliersFraction?: number;
                whiteOutliersFraction?: number;
            } & {
                readonly _type: "GrayscaleFilter";
            }) | ({
                blackPoint?: number;
                whitePoint?: number;
            } & {
                readonly _type: "WhiteBlackPointFilter";
            });
        }) => Promise<import("../core-types").ObjectId<"PdfGenerationContext">>;
        addPageToPdf: (pdfOperation: import("../core-types").ObjectId<"PdfGenerationContext">, image: import("../core-types").Image, binarization?: import("../core-types").PageBinarization) => Promise<void>;
        addPageToPdfWithOcr: (pdfOperation: import("../core-types").ObjectId<"PdfGenerationContext">, image: import("../core-types").Image, binarization?: import("../core-types").PageBinarization) => Promise<void>;
        completePdf: (pdfOperation: import("../core-types").ObjectId<"PdfGenerationContext">) => Promise<Uint8Array>;
        beginTiff: (options: {
            compression?: import("../core-types").CompressionMode;
            jpegQuality?: number;
            zipCompressionLevel?: number;
            dpi?: number;
            userFields?: {
                tag?: number;
                name?: string;
                value?: ({
                    value?: number;
                } & {
                    readonly _type: "UserFieldDoubleValue";
                }) | ({
                    value?: string;
                } & {
                    readonly _type: "UserFieldStringValue";
                }) | ({
                    value?: number;
                } & {
                    readonly _type: "UserFieldIntValue";
                });
            }[];
            binarizationFilter?: ({
                filterType?: number;
            } & {
                readonly _type: "LegacyFilter";
            }) | ({
                outputMode?: import("../core-types").OutputMode;
            } & {
                readonly _type: "ScanbotBinarizationFilter";
            }) | ({
                outputMode?: import("../core-types").OutputMode;
                denoise?: number;
                radius?: number;
                preset?: import("../core-types").BinarizationFilterPreset;
            } & {
                readonly _type: "CustomBinarizationFilter";
            }) | ({
                radius?: number;
                borderWidthFraction?: number;
                blackOutliersFraction?: number;
                whiteOutliersFraction?: number;
                contrastEnhancement?: number;
                colorEnhancement?: number;
                paperWhitening?: number;
                paperWhiteningBias?: number;
            } & {
                readonly _type: "ColorDocumentFilter";
            }) | ({
                brightness?: number;
            } & {
                readonly _type: "BrightnessFilter";
            }) | ({
                contrast?: number;
            } & {
                readonly _type: "ContrastFilter";
            }) | ({
                borderWidthFraction?: number;
                blackOutliersFraction?: number;
                whiteOutliersFraction?: number;
            } & {
                readonly _type: "GrayscaleFilter";
            }) | ({
                blackPoint?: number;
                whitePoint?: number;
            } & {
                readonly _type: "WhiteBlackPointFilter";
            });
        }) => Promise<import("../core-types").ObjectId<"TiffGenerationContext">>;
        addPageToTiff: (tiffOperation: import("../core-types").ObjectId<"TiffGenerationContext">, image: import("../core-types").Image, binarization: import("../core-types").PageBinarization) => Promise<void>;
        completeTiff: (tiffOperation: import("../core-types").ObjectId<"TiffGenerationContext">) => Promise<Uint8Array>;
        releaseObject: <T>(objectToken: import("../core-types").ObjectId<T>) => Promise<void>;
        version: () => Promise<string>;
    };
    readonly api: BridgeApiEntrypoint;
    private getCoreForCommand;
}
